#pragma once

#include <glm/geometric.hpp>
namespace xrn::bsim::system {

///////////////////////////////////////////////////////////////////////////
/// \brief Scene of the came
/// \ingroup game
///
/// \include Scene.hpp <Game/Scene.hpp>
///
///////////////////////////////////////////////////////////////////////////
class BoidBehavior
{

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Component aliases
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    using Position = ::xrn::engine::component::Position;
    using Rotation = ::xrn::engine::component::Rotation;
    using Scale = ::xrn::engine::component::Scale;
    using Transform3d = ::xrn::engine::component::Transform3d;
    using Control = ::xrn::engine::component::Control;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Static
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    static inline constexpr const ::std::size_t numberOfBoids{ 200 };
    static inline constexpr const ::std::size_t defaultSpeed{ 1000 };
    static inline constexpr const float defaultScale{ 0.2f };

    struct Boid {}; // Signature type to assign

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Basic
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void update(
        ::entt::entity boid
        , BoidBehavior::Position& position [[ maybe_unused ]]
        , BoidBehavior::Rotation& rotation [[ maybe_unused ]]
        , BoidBehavior::Control& control [[ maybe_unused ]]
        , const auto& boids
    ) const
    {
        ::glm::vec3 desiredHeading{ 0.f };
        auto i{ 0 };

        for (const auto [ otherBoid, otherPosition, otherRotation, otherControl ] : boids.each()) {
            if (otherBoid == boid) continue; // skip self

            const auto distance{ ::glm::distance(position.get(), otherPosition.get()) };
            if (distance > m_perceptionRadius) continue; // skip boids outside of range

            // alignment
            desiredHeading += otherRotation.get();
            ++i;
        }

        if (i > 0) {
            desiredHeading /= static_cast<float>(i);
            // desiredHeading = ::glm::normalize(const vec<L, T, Q> &x);
        }

        rotation.set(desiredHeading);
    }



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Member variables
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    float m_perceptionRadius{ 5.f };
    float m_maxForce{ 1.f };

};

} // namespace xrn::bsim::system
