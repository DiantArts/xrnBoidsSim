#pragma once

#include <atomic>
#include <condition_variable>
#include <xrn/BoidsSim/System/BoidBehavior.hpp>

namespace xrn::bsim {

///////////////////////////////////////////////////////////////////////////
/// \brief Scene of the came
/// \ingroup game
///
/// \include Scene.hpp <Game/Scene.hpp>
///
///////////////////////////////////////////////////////////////////////////
class Scene
    : public ::xrn::engine::AScene
{

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Component aliases
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    using Position = ::xrn::engine::component::Position;
    using Velocity = ::xrn::engine::component::Velocity;
    using Acceleration = ::xrn::engine::component::Acceleration;
    using Direction = ::xrn::engine::component::Direction;
    using Scale = ::xrn::engine::component::Scale;
    using Mass = ::xrn::engine::component::Mass;
    using Transform3d = ::xrn::engine::component::Transform3d;
    using Control = ::xrn::engine::component::Control;
    using PointLight = ::xrn::engine::component::PointLight;
    using BoidBehavior = ::xrn::bsim::system::BoidBehavior;



public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Scene();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Events
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// if return false, scene exits
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto onUpdate()
        -> bool override;

    ///////////////////////////////////////////////////////////////////////////
    /// if return false, scene exits
    ///////////////////////////////////////////////////////////////////////////
    // [[ nodiscard ]] auto onPostUpdate()
        // -> bool override;

    ///////////////////////////////////////////////////////////////////////////
    /// called with the m_tickFrequencyTime per seconds
    ///////////////////////////////////////////////////////////////////////////
    // [[ nodiscard ]] auto onTick(
        // ::xrn::Time deltaTime
    // ) -> bool override;

    ///////////////////////////////////////////////////////////////////////////
    /// Automatically called when handling events
    /// Called if camera is not detached
    ///////////////////////////////////////////////////////////////////////////
    // void onKeyPressed(
        // ::std::int16_t keyCode
    // ) override;

    ///////////////////////////////////////////////////////////////////////////
    /// Automatically called when handling events
    /// Called if camera is not detached
    ///////////////////////////////////////////////////////////////////////////
    // void onKeyReleased(
        // ::std::int16_t keyCode
    // ) override;

    ///////////////////////////////////////////////////////////////////////////
    /// Automatically called when handling events
    /// Called if camera is not detached
    ///////////////////////////////////////////////////////////////////////////
    // void onMouseMoved(
        // ::glm::vec2 position
    // ) override;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Healers
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void createBoids();

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void initBoid(
        ::entt::entity boid
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static auto getPartitionIndex(
        const ::glm::vec3& position
    ) -> ::xrn::bsim::system::detail::PartitionIndex;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static auto getPartitionIndexBegin(
        const ::xrn::bsim::system::detail::PartitionIndex& partitionIndex
    ) -> ::xrn::bsim::system::detail::PartitionIndex;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static auto getPartitionIndexEnd(
        const ::xrn::bsim::system::detail::PartitionIndex& partitionIndex
    ) -> ::xrn::bsim::system::detail::PartitionIndex;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void updateBoids(
        ::std::size_t threadIndex
    );



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Systems
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// Boid updater system
    ///
    ///////////////////////////////////////////////////////////////////////////
    Scene::BoidBehavior m_boidBehavior;

    ///////////////////////////////////////////////////////////////////////////
    /// All the entities seperated in threads
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::std::array<::std::vector<::entt::entity>, Scene::BoidBehavior::numberOfThread> m_entities;

    ///////////////////////////////////////////////////////////////////////////
    /// Thread workers
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::xrn::SyncedThreads m_threads;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Space partitioning
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// Partitions
    ///
    ///////////////////////////////////////////////////////////////////////////
    Scene::BoidBehavior::PartitionArray m_partitions;

};

} // namespace xrn::bsim
